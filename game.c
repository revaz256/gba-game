#include "game.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
#include "images/start.h"
#include "images/lost.h"
#include "images/play.h"
#include "images/garbage.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app.
typedef enum {
  START,
  PLAY,
  LOSE,
} GBAState;



int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial game state
GBAState state = START;

struct x paddle;
struct y ball;

while (1) {
    currentButtons = BUTTONS;  // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();
    if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
        state = START;
    }

    switch (state) {
    case START:
        drawFullScreenImageDMA(start);
        // initialize paddle position
        paddle.width = 25;
        paddle.height = 5;
        paddle.column = 97;
        paddle.row = 125;
        paddle.oldRow = paddle.row;
        paddle.oldColumn = paddle.column;

        //initialize ball
        ball.x = 0;
        ball.y = 1;

        char start[12];
        sprintf(start, "Press START");
        drawString(130, 80, start, BLACK);
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
            state = PLAY;
        }
        // state = ?
        break;
    case PLAY:
        fillScreenDMA(BLACK);
        drawImageDMA(0, 0, 50, 37, garbage);

        // set boundaries for paddle
        if (paddle.column < 2) {
            paddle.oldColumn = paddle.column;
            paddle.column = 2;
        }
        if (paddle.column + paddle.width > 238) {
            paddle.oldColumn = paddle.column;
            paddle.column = 238 - paddle.width;
        }

        // move paddle
        if (KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons, previousButtons) || KEY_DOWN(BUTTON_LEFT, currentButtons)) {
            paddle.column -= 1;
        }
        else if (KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons, previousButtons) || KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
            paddle.column += 1;
        }
        else if (KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons) || KEY_DOWN(BUTTON_UP, currentButtons)) {
            paddle.row -= 1;
        }
        else if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons) || KEY_DOWN(BUTTON_DOWN, currentButtons)) {
            paddle.row += 1;
        }

        // erase old paddle
        drawRectDMA(paddle.oldRow, paddle.oldColumn, paddle.width, paddle.height, BLACK);

        // new paddle
        drawRectDMA(paddle.row, paddle.column, paddle.width, paddle.height, RED);
        // ball movement

        drawRectDMA(ball.y, ball.x, 150, 5, BLACK);
        ball.y += 2;
        drawRectDMA(ball.y, ball.x, 150, 5, WHITE);
        if (ball.y <= paddle.row + 5 && ball.y >= paddle.row && paddle.column <= 150) {
            state = LOSE;
        }
        if (ball.y >= 160) {
            ball.y = 1;
        }

        char showScore[23];
        sprintf(showScore, "AVOID THE WHITE BAR!!");
        drawString(150, 50, showScore, YELLOW);

        // update paddle
        paddle.oldColumn = paddle.column;
        paddle.oldRow = paddle.row;
          
        // state = ?
        break;
      case LOSE:
          drawFullScreenImageDMA(lose);
          char lose[22];
          sprintf(lose, "Gotcha! You made it too easy.");
          drawString(120, 20, lose, YELLOW);
        // state = ?
        break;
    }

    previousButtons = currentButtons;  // Store the current state of the buttons
  }

  UNUSED(previousButtons);  // You can remove this once previousButtons is used

  return 0;
}
